#!/bin/sh
# entrypoint.sh
#
# Use env vars to update templated configs and enable/disable things based on the env vars that
# were set for this container.

# If FR_DEBUG is set, we don't want every error to terminate
if [ -z "$FR_DEBUG" ]; then
  echo "Starting with strict error checking..."
  set -e
else
  echo "DBG: FR_DEBUG specified, you'll need to manually crash this container even after radiusd exits."
fi

fr_conf_path=/etc/raddb
syslog_conf_path=/etc/syslog-ng.conf
mandatory_vars="FR_MY_FQDN FR_FLR_SECRET FR_FLR_IP_1 FR_FLR_IP_2"
syslog_vars="FR_LOG_SYSLOG_HOST FR_LOG_SYSLOG_PORT FR_LOG_SYSLOG_PROTO FR_LOG_SYSLOG_FAC FR_LOG_SYSLOG_SEV"

# Helper to do simple substitions of env vars in files, without logging secrets
# But first, let's narrow down the list of files we'll consider for replacement later
conf_files_with_placeholders=$(find "$fr_conf_path/" "$syslog_conf_path" -type f -exec grep -l 'FR_' {} +)
replace_var_in_conf() {
  var="$1"
  val=$(eval "printf '%s' \"\$$var\"") # safer than plain eval
  # Escape backslashes, ampersands, and pipe
  esc_val=$(printf '%s' "$val" | sed 's/[\/&|]/\\&/g')

  case "$var" in
    *PASS*|*SECRET*) echo "Replacing $var with **REDACTED**...";;
    *)               echo "Replacing $var with $esc_val...";;
  esac

  # Replace var across all relevant conf files
  for file in $conf_files_with_placeholders; do
    sed -i "s|$var|$esc_val|g" "$file"
  done
}


## General freeradius prep

# Remove mods that we're 100% certain we don't need
echo "Cleaning up pre-packaged mods we know we don't need/want..."
cd $fr_conf_path/mods-enabled
rm -f ./totp ./chap ./passwd ./ntlm_auth ./mschap ./eap ./files ./ldap ./pap ./replicate
echo "Cleaning up pre-packaged inner-tunnel site since we're a proxy..."
rm -f $fr_conf_path/sites-enabled/inner-tunnel

# Update our templated configs based on the env vars that were set for this container
echo "Updating freeradius config files to use values passed into the environment..."

# Sanity check for mandatory env vars and exit early if omitted
for var in $mandatory_vars; do
  eval "val=\$$var"
  if [ -z "$val" ]; then
    echo "ERROR: Mandatory env var $var is empty."
    exit 1
  else
    replace_var_in_conf "$var"
  fi
done

# Symlink the appropriate confs for our basic eduroam config (may already be linked)
cd $fr_conf_path/sites-enabled
ln -sf ../sites-available/default default


## Handle AP-related details
echo "Generating client configurations based on FR_WAP_IP..."

# Figure out WAP/controller info
if [ -z "$FR_WAP_SECRET" ] || [ -z "$FR_WAP_IP" ]; then
  echo "ERROR: You must provide both FR_WAP_SECRET and FR_WAP_IP."
  exit 1
fi

# Split FR_WAP_IP by comma (ipv4, ipv6, cidr subnets, and hostnames are OK)
# Use lazyish ipv6 checking: if there's a colon, it's ipv6, otherwise it must be ipv4
idx=0
for addr in $(printf %s "$FR_WAP_IP" | tr ',' ' '); do
    [ -n "$addr" ] || continue
    case "$addr" in *:*) addr_type=ipv6addr ;; *) addr_type=ipaddr ;; esac

    this_client_conf="$fr_conf_path/clients.d/wap-$idx.conf"
    echo "Generating $this_client_conf for client '$addr'..."
    cat >"$this_client_conf" <<EOF
# Auto-generated by entrypoint script
client wap-$idx {
    $addr_type = $addr
    secret = '$FR_WAP_SECRET'
    nastype = wireless
    require_message_authenticator = yes
}
EOF
    chmod 0640 "$this_client_conf"
    idx=$((idx+1))
done
echo "Generated $idx clients."

# Figure out VLAN info; if VLANs were specified, use them; else toggle the VLAN config off
if [ -n "$FR_VLAN_VISITORS" ]; then
  echo "VLAN info provided for visitors; will enable VLAN assignment..."
  FR_VLAN_TOGGLE="true"
else
  echo "No VLAN info provided for visitors; will disable VLAN assignment..."
  FR_VLAN_TOGGLE="false"

  # Dummy value (nulled out in the config) because radiusd conf will fail to parse if blank
  FR_VLAN_VISITORS="1864"
fi

# Figured out WAP/controller and VLAN details, now do it
for var in FR_VLAN_TOGGLE FR_VLAN_VISITORS; do
  replace_var_in_conf "$var"
done


## Set up logging
if [ -n "$FR_LOG_DESTINATION" ]; then
  # If FR_DEBUG is set, log more details than usual
  if [ -n "$FR_DEBUG" ]; then
    echo "DBG: FR_DEBUG specified, will log every received RADIUS packet..."
    FR_VERBOSE_TOGGLE="true"
  else
    FR_VERBOSE_TOGGLE="false"
  fi
  replace_var_in_conf FR_VERBOSE_TOGGLE

  if [ "$FR_LOG_DESTINATION" = "syslog" ]; then
    echo "Setting up logging: syslog..."

    # Use correct linelog config
    cd $fr_conf_path/mods-enabled
    ln -sf ../mods-available/linelog-syslog linelog

    # Sanity check for syslog-specific env vars and exit early if omitted
    for var in $syslog_vars; do
      eval "val=\$$var"
      if [ -z "$val" ]; then
        echo "ERROR: syslog logging requires env var $var."
        exit 1
      else
        replace_var_in_conf "$var"
      fi
    done

    # busybox's syslogd only supports UDP, so we're using syslog-ng; fortunately for us, config is easy
    echo "Starting syslog-ng using $syslog_conf_path..."
    case "$FR_LOG_SYSLOG_PROTO" in
      TCP|tcp|UDP|udp)
        syslog-ng --no-caps -f $syslog_conf_path &
        syslog_pid=$!
        sleep 1 # just in case...
        ;;
      *) echo "ERROR: FR_LOG_SYSLOG_PROTO must be 'tcp' or 'udp'." && exit 1 ;;
    esac
    echo "Spawned syslog-ng (pid $syslog_pid), forwarding to $FR_LOG_SYSLOG_HOST:$FR_LOG_SYSLOG_PORT via $FR_LOG_SYSLOG_PROTO."

  elif [ "$FR_LOG_DESTINATION" = "file" ]; then
    echo "Setting up logging: file..."

    # Use correct linelog config
    cd $fr_conf_path/mods-enabled
    ln -sf ../mods-available/linelog-file linelog

    # If the log file is empty, this is our first run (OK) or we didn't persist in a previous run (BAD)
    mkdir -p /var/log/freeradius
    logfile_path="/var/log/freeradius/eduroam.log"
    if [ ! -s "$logfile_path" ]; then
      echo "*** Log is empty. You MUST retain 90 days of logs. Ensure $logfile_path is persistently mapped/bound, or logs will disappear when this container exits. ***"
      touch $logfile_path && chmod 0600 $logfile_path # so you can tail -f it immediately after startup
    fi
    echo "Logs will be written to $logfile_path."

  else
    echo "ERROR: FR_LOG_DESTINATION must be 'file' or 'syslog'."
    exit 1
  fi
else
  echo "ERROR: FR_LOG_DESTINATION is required."
  exit 1
fi

## Enable proxy rate limiting module
ln -sf ../mods-available/proxy_rate_limit proxy_rate_limit


## Cleanup traps (to avoid orphaning bg jobs)
cleanup() {
  echo "Stopping syslog-ng if running..."
  kill "$syslog_pid" 2>/dev/null
}
term_handler() {
  echo "Stopping FreeRADIUS cleanly..."
  kill -TERM "$radiusd_pid" 2>/dev/null
}
trap term_handler SIGTERM SIGINT
trap cleanup EXIT # i.e. call cleanup() when script exits


## Finally, start FreeRADIUS
echo "Why are we always preparing? Just go!"

# Note we don't use exec - if we did, our trap would never fire
if [ -n "$FR_DEBUG" ]; then
  echo "Starting FreeRADIUS in debug mode..."
  radiusd -X &
  radiusd_pid=$!
  wait "$radiusd_pid"

  # Wait to be forcefully terminated if we're debugging
  while true; do
   echo "DBG: Sleeping so you can inspect the running container...";
   sleep 3600;
  done
else
  echo "Starting FreeRADIUS (to debug, set FR_DEBUG to any value and restart)..."
  radiusd -f -l stdout &
  radiusd_pid=$! # need pid so we can exit gracefully when container itself is terminated
  wait "$radiusd_pid"
  ret=$?
fi

echo "FreeRADIUS has stopped with exit code $ret."

exit $ret
