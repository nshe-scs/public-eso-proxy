# Proxy-only config, forked from https://github.com/nshe-scs/public-eso-tools
# Modified so anything starting with FR_ is automagically set based on container env vars
# VLAN assignment is optional since it may already be handled downstream

# Unique identifier for this proxy
operator_name = "FR_MY_FQDN"

# The VLAN to assign eduroam visitors (if applicable)
eduroam_visitors_vlan = "FR_VLAN_VISITORS"

server eduroam {
        listen {
                type = auth
                ipaddr = *
                port = 1812
                # eduroam-US does not use accounting/1813, so we don't either
        }

        authorize {
                # Some work just for the very first packet in the session:
                # Store a session start timestamp (Tmp-Integer-0) so we can figure out
                # the total elapsed session time (Tmp-Integer-1) later; and a random-ish
                # Correlation-ID (Tmp-String-0) to help find things in the logs
                if (!&session-state:Tmp-Integer-0) {
                        update session-state {
                                Tmp-Integer-0 := "%{expr:%c*1000 + %C/1000}"
                                Tmp-String-0 := "%{rand:100000}-%l"
                        }
                }

                # Copy Correlation-ID to control on every packet
                update control {
                        Tmp-String-0 := "%{session-state:Tmp-String-0}"
                }

                # Count packets (Tmp-Integer-2) for logging later at the final accept/reject
                update session-state {
                        Tmp-Integer-2 := "%{expr:%{%{session-state:Tmp-Integer-2}:-0} + 1}"
                }

                # Only log every received packet if debugging
                if ("FR_VERBOSE_TOGGLE" == "true"){
                        linelog_recv_request
                }

                # Reject non-EAP auths
                if (!&EAP-Message) {
                        reject
                }

                # split_username_nai is a policy in the default distribution to
                # split a username into username and domain.  We reject user-name
                # strings without domains, as they're not routable.
                split_username_nai
                if (noop || !&Stripped-User-Domain) {
                        reject
                }

                # Send the request to the FLRs in proxy.conf.
                update {
                        control:Load-Balance-Key := &Calling-Station-ID
                        control:Proxy-To-Realm := 'eduroam_flr'

                        # Operator name (RFC 5580) identifies the network the
                        # request originated from. It's not absolutely necessary
                        # but it helps with debugging.
                        request:Operator-Name := "1${operator_name}"
                }

                # Some clients aggressively retry, so be nice to your FLRs
                proxy_rate_limit
                if (reject) {
                        linelog_ratelimit
                }

                return
        }

        pre-proxy {
                attr_filter.pre-proxy
                linelog_send_proxy_request
        }

        post-proxy {
                attr_filter.post-proxy
                linelog_recv_proxy_response
        }

        # No local auth; we're a proxy
        authenticate {
                return
        }

        post-auth {
                # Optionally set VLAN for visitors
                if ("FR_VLAN_TOGGLE" == "true"){
                        update reply {
                                Tunnel-Type := VLAN
                                Tunnel-Medium-Type := IEEE-802
                        }
                        if (&control:Proxy-To-Realm) {
                                update reply {
                                        Tunnel-Private-Group-ID = ${eduroam_visitors_vlan}
                                }
                        }
                }

                # Compute total elapsed time (Tmp-Integer-1) from first packet's timestamp, i.e.
                # (now_milliseconds) - (first_packet_milliseconds)
                # and if we somehow got here without a start timestamp:
                # (now_milliseconds) - (now_milliseconds)
                if (&session-state:Tmp-Integer-0){
                        update session-state { Tmp-Integer-1 := "%{expr:(%c*1000 + %C/1000) - %{session-state:Tmp-Integer-0}}" }
                } else {
                        update session-state { Tmp-Integer-1 := 0 }
                }

                linelog_send_accept

                Post-Auth-Type REJECT {
                        attr_filter.access_reject
                        linelog_send_reject
                }
        }
}
